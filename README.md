
### **项目交接文档：基于OCR的屏幕监控系统**

**项目名称**：屏幕文字/模板监控系统
**核心功能**：定期监控屏幕特定区域，通过OCR识别文字或模板匹配，检测预设关键词或图像，触发相应动作。

---

### **一、 项目结构与文件说明**

项目包含两个核心文件：

1.  **`config.py`**：
    *   **作用**：**主要配置文件**。定义了所有可调整的参数。
    *   **内容**：
        *   `GLOBAL_CONFIG`：全局设置（监控间隔、日志路径、截图目录、OCR语言等）。
        *   `RECOGNITION_CONFIGS`：**核心配置列表**。定义了需要监控的任务，包括检测区域、关键词、匹配后动作等。支持嵌套检测。
    *   **运行方式**：可以直接运行 `python config.py` 来启动整个程序（因为它会导入并运行 `main.py`）。

2.  **`main.py`**：
    *   **作用**：**主程序逻辑文件**。包含了所有功能的实现代码。
    *   **内容**：截图、图像预处理、OCR识别、模板匹配、回调执行、日志记录、主循环等。
    *   **运行方式**：通常通过 `config.py` 启动，也可以直接运行 `python main.py`。

---

### **二、 环境准备与启动流程**

#### **1. 环境准备**
新人接手的第一步是确保运行环境正确。

*   **Python 版本**：需要 Python 3.6 或更高版本。
*   **安装 Python 依赖库**：
    *   打开命令行（Terminal/Command Prompt）。
    *   导航到项目文件夹。
    *   执行命令：
        ```bash
        pip install pytesseract pillow opencv-python pyautogui
        ```
*   **安装 Tesseract OCR 引擎**：
    *   `pytesseract` 是一个 Python 封装，它需要底层的 Tesseract OCR 引擎才能工作。
    *   **Windows**：下载并安装 [Tesseract for Windows](https://github.com/UB-Mannheim/tesseract/wiki)。安装时记住安装路径（如 `C:\Program Files\Tesseract-OCR\tesseract.exe`）。
    *   **macOS**：使用 Homebrew 安装：`brew install tesseract`。
    *   **Linux (Ubuntu/Debian)**：`sudo apt-get install tesseract-ocr`。
*   **配置 Tesseract 路径 (Windows 可能需要)**：
    *   如果安装后程序报错找不到 `tesseract`，需要在 `main.py` 的开头（`import pytesseract` 之后）添加一行代码指定路径：
        ```python
        pytesseract.pytesseract.tesseract_cmd = r'C:\Program Files\Tesseract-OCR\tesseract.exe' # 修改为你的实际路径
        ```
    *   macOS 和 Linux 通常不需要此步骤。

#### **2. 启动程序**
*   **推荐方式**：运行 `config.py`。
    ```bash
    python config.py
    ```
*   **效果**：程序启动，根据 `config.py` 中的配置开始运行。

---

### **三、 程序运行流程与日志解读**

程序的核心是一个**无限循环**，按照 `GLOBAL_CONFIG["monitor_interval_seconds"]` 指定的时间（默认60秒）重复执行。

#### **主循环流程 (每轮循环)**

1.  **开始循环**：
    *   **日志**：
        ```
        ==================================================
        2025-08-19 12:00:00 - INFO - 开始新一轮监控循环
        ```
    *   **说明**：标志着新的一轮监控开始。

2.  **遍历并执行配置**：
    *   程序会遍历 `RECOGNITION_CONFIGS` 列表中的每一个启用的配置项。
    *   对于每一个配置项，执行 `execute_detection` 函数。

#### **单个检测任务执行流程 (`execute_detection`)**

以 `RECOGNITION_CONFIGS` 中的第一个配置（"第一层文字检测"）为例：

1.  **开始检测**：
    *   **日志**：
        ```
        2025-08-19 12:00:01 - INFO - 开始检测: 第一层文字检测 (层级 1)
        ```
    *   **说明**：开始处理这个配置项。

2.  **截图**：
    *   **操作**：程序截取 `x=100, y=100, width=300, height=150` 的区域。
    *   **日志 (如果 `debug_mode=True`)**：
        ```
        2025-08-19 12:00:01 - DEBUG - 截图已保存: screenshot_20250819_120001_123456.png
        ```
    *   **说明**：截图文件会保存在 `screenshots` 目录下，文件名包含时间戳。

3.  **图像预处理**：
    *   **操作**：根据配置，对截图进行高斯模糊和阈值处理（Otsu方法），以提高OCR识别率。
    *   **日志**：通常没有直接日志，但如果处理失败会有错误日志。

4.  **OCR 识别**：
    *   **操作**：使用 Tesseract OCR 识别处理后的图像中的文字，语言为 `chi_sim` (简体中文)。
    *   **关键日志**：
        ```
        2025-08-19 12:00:02 - DEBUG - OCR识别结果: '这是第一层的测试文字，包含关键词'
        ```
    *   **说明**：**这是最重要的调试信息！** 无论后续匹配是否成功，这行日志都会打印，让你知道OCR到底识别出了什么。如果识别结果是乱码或空，说明需要调整区域、预处理参数或OCR语言。

5.  **关键词匹配**：
    *   **操作**：检查 OCR 结果是否包含 `["第一层关键词"]`。
    *   **情况一：匹配成功**
        *   **日志**：
            ```
            2025-08-19 12:00:02 - INFO - 执行回调: 第一层检测成功 (坐标: 250, 175)
            2025-08-19 12:00:02 - INFO - ✓ 检测成功: 第一层文字检测
            ```
        *   **说明**：`✓` 表示成功。然后会执行 `callback_params["message"]` 定义的动作（这里是打印日志）。
        *   **嵌套检测**：因为配置了 `nested_detection`，程序会继续执行第二层检测。日志会显示：
            ```
            2025-08-19 12:00:02 - INFO - 开始检测: 第二层检测 (层级 2)
            2025-08-19 12:00:02 - DEBUG - OCR识别结果: '第二层关键词在这里'
            2025-08-19 12:00:02 - INFO - 执行回调: 第二层检测成功 (坐标: 255, 180)
            2025-08-19 12:00:02 - INFO - ✓ 检测成功: 第二层检测
            ```
        *   **最终结果**：整个第一层配置返回 `True`（成功）。
    *   **情况二：匹配失败**
        *   **日志**：
            ```
            2025-08-19 12:00:02 - DEBUG - 未找到关键词，检测失败
            2025-08-19 12:00:02 - WARNING - ✗ 检测失败: 第一层文字检测
            ```
        *   **说明**：`✗` 表示失败。**关键点**：即使失败，你也看到了 `OCR识别结果` 的日志，这告诉你OCR看到了什么，为什么没匹配上（比如关键词没识别出来、拼写错误等）。
        *   **嵌套检测**：不会执行。

6.  **处理下一个配置**：
    *   如果 `RECOGNITION_CONFIGS` 中有下一个启用的配置（如"模板匹配检测"），程序会重复上述流程。

7.  **等待下一次循环**：
    *   **日志**：
        ```
        2025-08-19 12:00:02 - DEBUG - 等待 60 秒后执行下一次监控...
        ```
    *   **说明**：程序暂停，等待 `monitor_interval_seconds` 秒后开始下一轮。

---

### **四、 不同情况下的日志与应对**

| 情况 | 关键日志特征 | 可能原因 | 应对措施 |
| :--- | :--- | :--- | :--- |
| **正常运行** | `开始新一轮监控循环` -> `开始检测: XXX` -> `OCR识别结果: '...'` -> `✓ 检测成功: XXX` -> `等待 XX 秒...` | 一切正常 | 无需操作 |
| **OCR识别失败** | `OCR识别结果: ''` 或 `OCR识别结果: '乱码字符'` | 区域错误、预处理不当、字体/背景复杂、Tesseract引擎问题 | 1. 检查 `x, y, width, height` 是否正确。<br>2. 调整 `preprocess` 配置（如尝试关闭模糊、调整阈值）。<br>3. 检查Tesseract安装和路径。<br>4. 考虑使用 `template` 模式。 |
| **关键词匹配失败** | `OCR识别结果: '实际识别的文字'` -> `未找到关键词，检测失败` -> `✗ 检测失败: XXX` | OCR结果中确实没有关键词、关键词拼写错误、大小写问题 | 1. **根据 `OCR识别结果` 日志，确认实际识别出的文字。**<br>2. 检查 `keywords` 列表中的关键词是否与识别结果完全匹配（注意空格、标点）。<br>3. 考虑设置 `"case_sensitive": False`。 |
| **截图失败** | `截图失败: ...` | 屏幕权限问题、区域超出屏幕范围 | 检查区域坐标是否有效，确保程序有访问屏幕的权限。 |
| **依赖库缺失** | `缺少必要的依赖库: ...` | 未安装 `pip install` 命令中的库 | 运行 `pip install` 命令安装缺失的库。 |
| **Tesseract未找到** | `pytesseract.pytesseract.TesseractNotFoundError` | Tesseract OCR引擎未安装或路径未配置 | 安装Tesseract，并在 `main.py` 中设置 `tesseract_cmd` 路径。 |
| **嵌套检测失败** | 第一层成功，但第二层出现 `✗ 检测失败` | 第二层的区域、关键词或识别问题 | 检查第二层的 `width`, `height`, `keywords` 配置。**特别注意**：第二层的坐标是相对于第一层匹配点的，确保区域设置正确。 |

---

### **五、 重要配置项说明 (`config.py`)**

*   **`monitor_interval_seconds`**：调整监控频率。值越小，监控越频繁，但CPU占用越高。
*   **`debug_mode`**：**强烈建议在调试时保持 `True`**。它能输出详细的 `DEBUG` 级日志（如OCR结果），是排查问题的关键。上线后可改为 `False` 减少日志量。
*   **`retention_hours`**：自动清理过期截图。设置为 `0` 表示不清理。
*   **`RECOGNITION_CONFIGS`**：
    *   `enabled`: 快速启用/禁用某个检测。
    *   `type`: `"text"` 或 `"template"`。
    *   `keywords`: 可以是多个关键词的列表，满足任意一个即成功。
    *   `callback_type`: `"logging"` (记录日志), `"mouse_click"` (点击), `"keyboard_input"` (输入文字)。
    *   `nested_detection`: 实现复杂逻辑的关键，支持无限嵌套。

---

### **六、 总结与建议**

1.  **启动前**：务必完成**环境准备**，这是最常见的问题来源。
2.  **调试时**：**保持 `debug_mode=True`**，`OCR识别结果` 日志是你的“眼睛”，能直接告诉你问题出在哪里。
3.  **分析日志**：遇到问题，首先看日志，特别是 `DEBUG` 和 `WARNING` 级别的信息，它们提供了详细的上下文。
4.  **修改配置**：所有功能调整都通过修改 `config.py` 完成，无需改动 `main.py` 的核心逻辑。
5.  **测试**：修改配置后，重启程序观察日志输出是否符合预期。
